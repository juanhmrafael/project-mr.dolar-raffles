# docker-compose.yml para PRODUCCIÓN (DockerGuard Standard v4.0 - Auditado y Endurecido)
# ====================================================================================================
# Propósito: Manifiesto de arquitectura de producción unificado y seguro.
# Refactorizado para usar la configuración endurecida de Redis y Docker Secrets para TODAS las credenciales.
# Fuente Canónica de Compose: https://docs.docker.com/reference/compose-file/
# Fuente Canónica de Secrets: https://docs.docker.com/compose/use-secrets/
# ====================================================================================================

x-django-base: &django-base
  image: fullstack-raffle:backend-prod
  # --- MODIFICACIÓN DE SEGURIDAD CRÍTICA ---
  # Se elimina 'env_file'. Las credenciales se gestionan exclusivamente con Docker Secrets.
  secrets:
    - postgres_user
    - postgres_password
    - postgres_db
    - redis_appuser_password # El backend también necesita la contraseña de Redis
  # Las variables de entorno ahora solo contienen configuración NO sensible.
  environment:
    - PYTHONPATH=/home/appuser/app/apps
    # El entrypoint.sh leerá los secretos y los exportará a estas variables para la aplicación.
    - DB_HOST=db
    - DB_PORT=5432
    - REDIS_HOST=redis
    - REDIS_PORT=6379
    - REDIS_USER=appuser # El nuevo usuario ACL de Redis
  networks:
    - app_network
  restart: unless-stopped
  depends_on:
    db:
      condition: service_healthy
    redis:
      condition: service_healthy # Dependencia en un Redis saludable y autenticado.
  logging:
    driver: "json-file"
    options:
      max-size: "10m"
      max-file: "3"

services:
  # --- Servicio de Base de Datos: PostgreSQL (Endurecido) ---
  db:
    build:
      context: ./database
      dockerfile: Dockerfile
      args: { GLIBC_VER: 2.35-r1 }
    # --- MODIFICACIÓN DE SEGURIDAD CRÍTICA ---
    # Se elimina 'env_file'. Se usan secrets.
    secrets:
      - postgres_user
      - postgres_password
      - postgres_db
    # El entrypoint oficial de la imagen de Postgres buscará estas variables _FILE
    # y leerá las credenciales desde los archivos de secrets montados, evitando exponerlas.
    environment:
      - POSTGRES_USER_FILE=/run/secrets/postgres_user
      - POSTGRES_PASSWORD_FILE=/run/secrets/postgres_password
      - POSTGRES_DB_FILE=/run/secrets/postgres_db
    volumes:
      - postgres_data:/var/lib/postgresql/data/
    networks:
      - app_network
    restart: unless-stopped
    deploy:
      resources:
        limits: { cpus: '1.5', memory: 2G }
        reservations: { cpus: '0.75', memory: 1G }
    stop_grace_period: 1m
    healthcheck:
      # El healthcheck ahora lee el usuario y la DB de los secretos para máxima seguridad.
      test: ["CMD-SHELL", "pg_isready -U $$(cat /run/secrets/postgres_user) -d $$(cat /run/secrets/postgres_db)"]
      interval: 10s
      timeout: 5s
      retries: 5

  # --- Servicio de Broker/Caché: Redis (Endurecido y Configurado Explícitamente) ---
  redis:
    image: redis:7-alpine
    # Monta el archivo de configuración auditado y un volumen para la persistencia AOF.
    volumes:
      - ./redis/redis.conf:/usr/local/etc/redis/redis.conf
      - redis_data:/data
    # Comando que inicia Redis con nuestro .conf Y APLICA LA SEGURIDAD ACL.
    command: >
      sh -c "exec redis-server /usr/local/etc/redis/redis.conf --user appuser +$$(cat /run/secrets/redis_appuser_password)"
    networks:
      - app_network
    restart: unless-stopped
    secrets:
      - redis_appuser_password
    deploy:
      resources:
        limits: { cpus: '0.5', memory: 512M }
        reservations: { cpus: '0.25', memory: 256M }
    healthcheck:
      # Healthcheck que se autentica como 'appuser' usando el secreto.
      test: ["CMD-SHELL", "redis-cli -u redis://appuser:$$(cat /run/secrets/redis_appuser_password)@127.0.0.1:6379 ping | grep PONG"]
      interval: 10s
      timeout: 5s
      retries: 5
    logging:
      driver: "json-file"
      options: { max-size: "10m", max-file: "3" }

  # --- Servicio de Backend: Django/Gunicorn (Con Healthcheck) ---
  backend:
    <<: *django-base
    build:
      context: .
      dockerfile: Dockerfile.backend
    expose:
      - 8000
    volumes:
      - staticfiles:/home/appuser/app/staticfiles
      - mediafiles:/home/appuser/app/mediafiles
    deploy:
      resources:
        limits: { cpus: '2.0', memory: 3G }
        reservations: { cpus: '1.0', memory: 1.5G }
    # --- MEJORA DE RESILIENCIA ---
    # Añadido un healthcheck para asegurar que Gunicorn está realmente respondiendo.
    healthcheck:
      test: ["CMD-SHELL", "wget --quiet --tries=1 --spider http://localhost:8000/healthz/ || exit 1"]
      interval: 15s
      timeout: 5s
      retries: 3
      start_period: 30s # Da tiempo a que Gunicorn arranque antes de empezar a verificar.
    command: ["web", "gunicorn", "--bind", "0.0.0.0:8000", "--workers", "5", "-k", "uvicorn.workers.UvicornWorker", "config.asgi:application"]

  # --- Servicio de Trabajador en Segundo Plano: Celery ---
  worker:
    <<: *django-base
    deploy:
      resources:
        limits: { cpus: '2.0', memory: 2G }
        reservations: { cpus: '1.0', memory: 1G }
    command: ["worker", "celery", "-A", "config", "worker", "-l", "info", "--concurrency=4", "--max-tasks-per-child=500"]

  # --- Servicio de Servidor Web / Proxy Inverso: Nginx (Más Resiliente) ---
  nginx:
    build:
      context: .
      dockerfile: nginx/Dockerfile.nginx
    image: fullstack-raffle:nginx-prod
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - staticfiles:/home/appuser/app/staticfiles:ro
      - mediafiles:/home/appuser/app/mediafiles:ro
    restart: unless-stopped
    networks:
      - app_network
    deploy:
      resources:
        limits: { cpus: '0.5', memory: 256M }
        reservations: { cpus: '0.25', memory: 128M }
    depends_on:
      # --- MEJORA DE RESILIENCIA ---
      # Ahora depende de que el backend esté saludable, no solo iniciado.
      # Esto previene errores 502 al arrancar el stack.
      backend:
        condition: service_healthy
      db:
        condition: service_healthy
      redis:
        condition: service_healthy

  # --- Servicio de Programador de Tareas: Celery Beat ---
  beat:
    <<: *django-base
    deploy:
      resources:
        limits: { cpus: '0.25', memory: 256M }
        reservations: { cpus: '0.1', memory: 128M }
    command: ["beat", "celery", "-A", "config", "beat", "-l", "info", "--scheduler", "django_celery_beat.schedulers:DatabaseScheduler"]

# --- CONFIGURACIÓN DE VOLÚMENES Y SECRETOS ---
networks:
  app_network:
    driver: bridge

volumes:
  postgres_data: {}
  staticfiles: {}
  mediafiles: {}
  redis_data: {} # Volumen para los datos persistentes de Redis (AOF)

# --- DEFINICIÓN CENTRALIZADA DE SECRETOS ---
# Docker Compose leerá los archivos de texto plano del directorio 'secrets'
# y los montará de forma segura como archivos dentro de cada contenedor que los necesite.
secrets:
  postgres_user:
    file: ./secrets/postgres_user.txt
  postgres_password:
    file: ./secrets/postgres_password.txt
  postgres_db:
    file: ./secrets/postgres_db.txt
  redis_appuser_password:
    file: ./secrets/redis_appuser_password.txt