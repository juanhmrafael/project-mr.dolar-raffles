# docker-compose.yml para PRODUCCIÓN (DockerGuard Standard v4.0 - Auditado y Endurecido)
# ====================================================================================================
# Propósito: Manifiesto de arquitectura de producción unificado y seguro.
# Refactorizado para usar la configuración endurecida de Redis y Docker Secrets para TODAS las credenciales.
# Fuente Canónica de Compose: https://docs.docker.com/reference/compose-file/
# Fuente Canónica de Secrets: https://docs.docker.com/compose/use-secrets/
# ====================================================================================================

x-django-base: &django-base
  image: fullstack-raffle:backend-prod
  secrets:
    - postgres_user
    - postgres_password
    - postgres_db
    - redis_appuser_password
    - django_secret_key     
    - field_encryption_key  
  environment:
    - PYTHONPATH=/home/appuser/app/apps
    - DB_HOST=db
    - DB_PORT=5432
    - REDIS_HOST=redis
    - REDIS_PORT=6379
    - REDIS_USER=appuser
  networks:
    - app_network
  restart: unless-stopped
  depends_on:
    db:
      condition: service_healthy
    redis:
      condition: service_healthy
  logging:
    driver: "json-file"
    options:
      max-size: "10m"
      max-file: "3"

services:
  # --- Servicio de Base de Datos: PostgreSQL (Endurecido) ---
  db:
    build:
      context: ./database
      dockerfile: Dockerfile
      args: { GLIBC_VER: 2.35-r1 }
    secrets:
      - postgres_user
      - postgres_password
      - postgres_db
    environment:
      - POSTGRES_USER_FILE=/run/secrets/postgres_user
      - POSTGRES_PASSWORD_FILE=/run/secrets/postgres_password
      - POSTGRES_DB_FILE=/run/secrets/postgres_db
    volumes:
      - postgres_data:/var/lib/postgresql/data/
    networks:
      - app_network
    restart: unless-stopped
    deploy:
      resources:
        limits: { cpus: '1.5', memory: 2G }
        reservations: { cpus: '0.75', memory: 1G }
    stop_grace_period: 1m
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U $$(cat /run/secrets/postgres_user) -d $$(cat /run/secrets/postgres_db)"]
      interval: 10s
      timeout: 5s
      retries: 5

  # --- Servicio de Broker/Caché: Redis (Endurecido y Configurado Explícitamente) ---
  redis:
    image: redis:7-alpine
    volumes:
      - ./redis/redis.conf:/usr/local/etc/redis/redis.conf
      - redis_data:/data
    command:
      - sh
      - -c
      - |
        PASSWORD=$$(cat /run/secrets/redis_appuser_password)
        sed "s/PASSWORD_PLACEHOLDER/$$PASSWORD/" /usr/local/etc/redis/redis.conf > /tmp/redis.conf
        exec redis-server /tmp/redis.conf
    networks:
      - app_network
    restart: unless-stopped
    secrets:
      - redis_appuser_password
    deploy:
      resources:
        limits: { cpus: '0.5', memory: 512M }
        reservations: { cpus: '0.25', memory: 256M }
    healthcheck:
      # Sintaxis más robusta y portable para el healthcheck.
      test: ["CMD", "sh", "-c", "redis-cli --user appuser -a \"$(cat /run/secrets/redis_appuser_password)\" ping | grep PONG"]
      interval: 10s
      timeout: 5s
      retries: 5
    logging:
      driver: "json-file"
      options: { max-size: "10m", max-file: "3" }

  # --- Servicio de Backend: Django/Gunicorn (Con Healthcheck Robusto) ---
  backend:
    <<: *django-base
    build:
      context: .
      dockerfile: Dockerfile.backend
    expose:
      - 8000
    volumes:
      - staticfiles:/home/appuser/app/staticfiles
      - mediafiles:/home/appuser/app/mediafiles
    deploy:
      resources:
        limits: { cpus: '2.0', memory: 3G }
        reservations: { cpus: '1.0', memory: 1.5G }
    healthcheck:
      # --- CORRECCIÓN CRÍTICA DE RESILIENCIA ---
      # Este healthcheck verifica si el puerto 8000 está escuchando dentro del contenedor.
      # Es más robusto que un curl a una URL, ya que solo comprueba si Gunicorn está vivo.
      test: ["CMD-SHELL", "nc -z localhost 8000 || exit 1"]
      interval: 15s
      timeout: 5s
      retries: 5
      start_period: 30s
    command: ["web", "gunicorn", "--bind", "0.0.0.0:8000", "--workers", "5", "-k", "uvicorn.workers.UvicornWorker", "config.asgi:application"]

  # --- Servicio de Trabajador en Segundo Plano: Celery ---
  worker:
    <<: *django-base
    deploy:
      resources:
        limits: { cpus: '2.0', memory: 2G }
        reservations: { cpus: '1.0', memory: 1G }
    command: ["worker", "celery", "-A", "config", "worker", "-l", "info", "--concurrency=4", "--max-tasks-per-child=500"]

  # --- Servicio de Servidor Web / Proxy Inverso: Nginx (Más Resiliente) ---
  nginx:
    build:
      context: .
      dockerfile: nginx/Dockerfile.nginx
    image: fullstack-raffle:nginx-prod
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - staticfiles:/home/appuser/app/staticfiles:ro
      - mediafiles:/home/appuser/app/mediafiles:ro
    restart: unless-stopped
    networks:
      - app_network
    deploy:
      resources:
        limits: { cpus: '0.5', memory: 256M }
        reservations: { cpus: '0.25', memory: 128M }
    depends_on:
      backend:
        condition: service_healthy
      db:
        condition: service_healthy
      redis:
        condition: service_healthy

  # --- Servicio de Programador de Tareas: Celery Beat ---
  beat:
    <<: *django-base
    deploy:
      resources:
        limits: { cpus: '0.25', memory: 256M }
        reservations: { cpus: '0.1', memory: 128M }
    command: ["beat", "celery", "-A", "config", "beat", "-l", "info", "--scheduler", "django_celery_beat.schedulers:DatabaseScheduler"]

# --- CONFIGURACIÓN DE VOLÚMENES Y SECRETOS ---
networks:
  app_network:
    driver: bridge

volumes:
  postgres_data: {}
  staticfiles: {}
  mediafiles: {}
  redis_data: {}

secrets:
  postgres_user:
    file: ./secrets/postgres_user.txt
  postgres_password:
    file: ./secrets/postgres_password.txt
  postgres_db:
    file: ./secrets/postgres_db.txt
  redis_appuser_password:
    file: ./secrets/redis_appuser_password.txt
  django_secret_key:
    file: ./secrets/django_secret_key.txt
  field_encryption_key:
    file: ./secrets/field_encryption_key.txt