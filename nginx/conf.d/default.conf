# Configuración de Nginx para PRODUCCIÓN
# ====================================================================================================
# Propósito: Esta es una configuración de Nginx endurecida ('hardened') y optimizada para un
# entorno de producción moderno. Cada directiva está intencionadamente elegida para maximizar
# la seguridad, la velocidad de carga y la eficiencia operativa.
# ====================================================================================================

# --- Bloque Upstream: El Directorio de Servicios Backend ---

# La directiva 'upstream' declara un grupo o "pool" de servidores con un nombre personalizado.
# Es una abstracción que mejora drásticamente la legibilidad y la mantenibilidad.
upstream django_api {
    # La directiva 'server' define un miembro de este grupo.
    # Propósito: Especifica la dirección del servicio de backend de Django.
    # Funcionamiento: 'backend_prod' no es una IP, es el nombre del servicio definido en tu
    # 'docker-compose.yml'. Docker tiene un DNS interno que resuelve este nombre a la dirección IP
    # privada del contenedor del backend. El puerto ':8000' es donde el servidor Gunicorn está
    # escuchando dentro de ese contenedor. Usar un 'upstream' te permitiría en el futuro
    # añadir más líneas 'server' para escalar horizontalmente tu backend y Nginx balancearía
    # la carga entre ellos automáticamente.
    server backend:8000;
}

# --- Bloque Server: El Corazón de la Configuración ---

# La directiva 'server' abre un bloque que define un "servidor virtual". Puedes tener múltiples
# bloques 'server' para manejar diferentes dominios en el mismo Nginx.
server {
    # La directiva 'listen' le dice a Nginx en qué puerto de red del contenedor debe escuchar
    # el tráfico entrante.
    # Propósito: Capturar todo el tráfico web estándar que llega por HTTP.
    # Funcionamiento: El puerto 80 es el puerto universal para el tráfico HTTP no encriptado.
    # En tu 'docker-compose.yml', mapeas un puerto de tu máquina host (ej. 80) a este puerto 80
    # del contenedor de Nginx, permitiendo que el tráfico del mundo exterior llegue aquí.
    listen 80;

    # La directiva 'client_max_body_size' establece el tamaño máximo permitido para el cuerpo
    # de una petición de un cliente.
    # Propósito: Controlar el tamaño de los archivos que los usuarios pueden subir.
    # Funcionamiento: Por defecto, Nginx tiene un límite muy bajo (1M). Si un usuario intenta subir
    # una imagen o archivo más grande que 20M, Nginx rechazará la petición con un error 413
    # ("Payload Too Large") sin siquiera molestar a tu aplicación Django. Es una primera
    # línea de defensa contra ataques de denegación de servicio por subidas masivas.
    client_max_body_size 20M;

    # --- Directivas de Seguridad Base (Security Hardening) ---

    # La directiva 'server_tokens' controla si Nginx revela su número de versión en las páginas
    # de error y en la cabecera 'Server' de las respuestas HTTP.
    # Propósito: Ocultar información del sistema (Principio de Menor Información).
    # Funcionamiento: Con 'off', la cabecera 'Server' simplemente dirá 'nginx' en lugar de
    # 'nginx/1.27.1'. Esto dificulta que un atacante automatizado pueda buscar tu versión
    # específica de Nginx en bases de datos de vulnerabilidades conocidas.
    server_tokens off;

    # La directiva 'add_header' añade una cabecera HTTP a la respuesta que se envía al navegador.
    # Propósito: Mitigar ataques de "Clickjacking".
    # Funcionamiento: Esta cabecera le dice al navegador que solo permita que tu página sea
    # renderizada dentro de un <frame> o <iframe> si la página que lo contiene pertenece al
    # mismo dominio ('SAMEORIGIN'). Esto previene que un sitio malicioso cargue tu web en un
    # iframe invisible y engañe al usuario para que haga clic en botones de tu sitio sin saberlo.
    add_header X-Frame-Options "SAMEORIGIN" always;

    # Propósito: Prevenir ataques de "MIME-type sniffing".
    # Funcionamiento: Le dice a navegadores como Internet Explorer y Chrome que no intenten
    # adivinar el tipo de contenido de un archivo. Si declaras que un archivo es 'text/plain',
    # el navegador no intentará ejecutarlo como si fuera 'text/javascript'. Esto bloquea
    # una clase de ataques donde un atacante sube un archivo que parece texto pero contiene
    # código malicioso.
    add_header X-Content-Type-Options "nosniff" always;

    # Propósito: Habilitar el filtro de Cross-Site Scripting (XSS) integrado en los navegadores.
    # Funcionamiento: Esta cabecera activa el filtro. 'mode=block' instruye al navegador a
    # bloquear completamente la renderización de la página si detecta un posible ataque XSS
    # reflejado, en lugar de intentar sanitizar el contenido.
    add_header X-XSS-Protection "1; mode=block" always;
    
    # --- Cabeceras de Seguridad Avanzadas (Hardening Adicional) ---

    # Propósito: Controlar la fuga de información a través de la cabecera 'Referer'.
    # Funcionamiento: Define qué información de la URL de origen se envía cuando un usuario
    # navega desde tu sitio a otro. 'strict-origin-when-cross-origin' es el estándar moderno:
    # si el enlace es a tu propio sitio, se envía la URL completa; si es a un sitio externo,
    # solo se envía el dominio raíz (ej. 'https://misitio.com'), protegiendo cualquier
    # dato sensible que pudiera estar en la ruta de la URL.
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;
    
    # Propósito: Controlar el acceso a las APIs del navegador (cámara, micrófono, etc.).
    # Funcionamiento: Sigue el Principio de Menor Privilegio. Esta política actúa como una
    # lista blanca de características del navegador. Al establecerlas en '()', se deshabilita
    # explícitamente su uso. Si un script malicioso intentara acceder al micrófono, el
    # navegador lo denegaría a nivel de política antes de que el script pudiera siquiera pedir permiso.
    add_header Permissions-Policy "accelerometer=(), camera=(), geolocation=(), gyroscope=(), magnetometer=(), microphone=(), payment=(), usb=()" always;

    # ¡ADVERTENCIA! Estas cabeceras avanzadas están comentadas porque su activación incorrecta puede romper tu sitio.
    # add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload" always;
    # add_header Content-Security-Policy "default-src 'self'; ...";

    # --- Bloques Location: El Sistema de Enrutamiento Interno ---

    # La directiva 'location' define reglas para URLs que coinciden con un patrón.
    # Este bloque maneja las peticiones que empiezan con '/static/'.
    location /static/ {
        # Propósito: Desactivar la escritura de logs para estas peticiones.
        # Funcionamiento: Servir activos estáticos es una operación de bajo riesgo y alto volumen.
        # Desactivar los logs para ellas reduce la carga de I/O en el disco del servidor y mantiene
        # los logs de acceso limpios y enfocados en las peticiones importantes a la API.
        access_log off;

        # La directiva 'alias' mapea una URL a una ruta del sistema de archivos.
        # Propósito: Indicar a Nginx dónde encontrar los archivos estáticos de Django.
        # Funcionamiento: Cuando llega una petición para '/static/css/admin.css', Nginx la
        # traduce a la ruta de archivo '/home/appuser/app/staticfiles/css/admin.css'. Esta
        # ruta debe coincidir exactamente con el destino del volumen montado en docker-compose.
        alias /home/appuser/app/staticfiles/;

        # La directiva 'expires' añade cabeceras de caché ('Expires' y 'Cache-Control').
        # Propósito: Instruir a los navegadores para que cacheen agresivamente estos archivos.
        # Funcionamiento: Le dice al navegador que el archivo es válido por 1 año ('1y').
        # La primera vez que lo descarga, lo guarda localmente. En visitas posteriores, lo
        # carga desde el disco instantáneamente, sin contactar a tu servidor.
        expires 1y;

        # Propósito: Informar a cachés intermedias (como CDNs) que el contenido es público.
        # Funcionamiento: La cabecera 'Cache-Control: public' permite que los proxies y CDNs
        # almacenen una copia y la sirvan a otros usuarios, reduciendo aún más la carga en tu servidor.
        add_header Cache-Control "public";
    }

    # Este bloque maneja las peticiones que empiezan con '/media/'.
    # Funciona de manera idéntica al bloque '/static/' pero para los archivos subidos por usuarios.
    location /media/ {
        access_log off;
        alias /home/appuser/app/mediafiles/;
        expires 1y;
        add_header Cache-Control "public";
    }

    # Este bloque maneja las peticiones que empiezan con '/api/'.
    location ~ ^/(admin|audit-admin|api|payments/api)/  {
        # La directiva 'proxy_pass' reenvía la petición a otro servidor.
        # Propósito: Enviar toda la lógica de negocio al backend de Django.
        # Funcionamiento: Toma la petición del cliente y la reenvía al grupo de servidores
        # 'django_api' que definimos al principio. Nginx espera la respuesta de Django y luego
        # se la devuelve al cliente original. Este es el corazón del "proxy inverso".
        proxy_pass http://django_api;

        # Las directivas 'proxy_set_header' modifican o añaden cabeceras a la petición que se
        # envía al servidor backend.
        # Propósito: Restaurar la información del cliente original que se pierde durante el proxy.
        # Funcionamiento: Para Django, todas las peticiones parecen venir de la IP de Nginx.
        # - 'Host': Le dice a Django cuál era el dominio original que el usuario solicitó.
        # - 'X-Real-IP': Le pasa la dirección IP real del cliente.
        # - 'X-Forwarded-For': Mantiene una lista de todas las IPs por las que ha pasado la petición.
        # - 'X-Forwarded-Proto': Le informa a Django si la conexión original del cliente fue HTTP o HTTPS.
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # Propósito: Ceder el control de las redirecciones a Django.
        # Funcionamiento: Evita que Nginx intente reescribir las cabeceras de redirección
        # (HTTP 3xx) enviadas por Django, asegurando que siempre sean correctas.
        proxy_redirect off;
    }

    # Este bloque 'location /' es el "catch-all" (atrapa todo). Maneja cualquier petición
    # que no haya coincidido con los bloques anteriores.
    location / {
        # La directiva 'root' especifica el directorio raíz para las peticiones.
        # Propósito: Apuntar al directorio que contiene la aplicación Angular compilada.
        root /usr/share/nginx/html;

        # La directiva 'index' especifica el archivo a servir si la URL es un directorio.
        index index.html;

        # La directiva 'try_files' es la clave para las Single-Page Applications (SPA).
        # Propósito: Permitir que el enrutamiento del lado del cliente de Angular funcione.
        # Funcionamiento: Nginx intenta servir un archivo que coincida exactamente con la URL
        # ($uri). Si no lo encuentra, intenta ver si es un directorio ($uri/). Si tampoco lo
        # encuentra, en lugar de devolver un error 404, sirve el archivo '/index.html'. Esto
        # carga tu aplicación Angular, y el enrutador de Angular lee la URL original y muestra
        # el componente correcto.
        try_files $uri $uri/ /index.html;
    }

    # --- Bloque de Optimización de Compresión Gzip ---

    # La directiva 'gzip' es el interruptor maestro para la compresión.
    gzip on;

    # Propósito: Asegurar que los proxies cacheen correctamente el contenido comprimido.
    # Funcionamiento: Añade la cabecera 'Vary: Accept-Encoding', que le dice a las cachés que
    # deben mantener una versión separada del archivo para clientes que aceptan Gzip y para los que no.
    gzip_vary on;

    # Propósito: Comprimir también las respuestas que vienen del backend (proxy).
    gzip_proxied any;

    # Propósito: Definir el nivel de compresión.
    # Funcionamiento: Es una escala del 1 al 9. Un nivel más alto comprime más pero usa más
    # CPU. El nivel 6 es universalmente aceptado como el mejor equilibrio entre ratio de
    # compresión y uso de recursos.
    gzip_comp_level 6;

    # Propósito: Asegurar la compatibilidad con clientes modernos.
    # Funcionamiento: Instruye a Nginx para que solo use Gzip en peticiones HTTP versión 1.1 o
    # superior. Es una buena práctica explícita, aunque en la práctica casi todos los clientes
    # modernos usan HTTP/1.1 o superior.
    gzip_http_version 1.1;

    # Propósito: Especificar qué tipos de contenido deben ser comprimidos.
    # Funcionamiento: Es inútil intentar comprimir archivos que ya están comprimidos (como
    # JPEG, PNG, ZIP). Esta directiva crea una lista blanca de tipos MIME basados en texto
    # que se benefician enormemente de la compresión.
    gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;
}